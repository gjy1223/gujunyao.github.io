---
layout: post
title: smartPtr心得
categories: cplusplus
keywords: auto_ptr,unique_ptr,share_ptr,weak_ptr
---
# 1. 不使用smart_ptr可能产生的问题

## 1.1 内存泄漏

```cpp
#include <iostream>
#include <cstdlib>

int main() {
    int* ptr = (int*)malloc(sizeof(int)); // 分配内存
    if (ptr == NULL) {
        std::cerr << "Memory allocation failed!" << std::endl;
        return 1;
    }
    // ... 使用 ptr 访问分配的内存 ...
    // 错误: 没有对 ptr 进行释放
    return 0;
}

```

上述代码使用malloc分配内存，但没有使用free来释放，造成内存泄漏

## 1.2 double free

```cpp
#include <iostream>
#include <cstdlib>

int main() {
    int* ptr = (int*)malloc(sizeof(int)); // 分配内存
    free(ptr); // 第一次释放
    free(ptr); // 第二次释放，导致double free错误
    return 0;
}

```

以上代码一个malloc对应了两个free，造成了double free的错误

## 1.3 野指针

```cpp
void main()
{
    char* p = (char *) malloc(10);
    strcpy(p, “abc”);
    free(p);  //p所指的内存被释放，但是p所指的地址仍然不变
    strcpy(p, “def”); // 错误
}
```

# 2. smart_ptr 小解

## 2.1 unique_ptr

独享指针，不能拷贝构造和赋值，但可以使用move转移所有权；离开作用域就自动释放独占了指针

```cpp
// Disable copy from lvalue.
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;
```

释放所有权 `sp.release()`, 返回raw pointer

```cpp
unique_ptr<int> p1 = make_unique<int>(1);
int* a = p1.release();
std::cout<<*a<<std::endl;
delete a; // you need to delete it manually
```

重置所有权 `sp.reset()`, 释放所有权，指向空指针

```cpp
unique_ptr<int> p1 = make_unique<int>(1);
p1.reset();
std::cout<<p1.get()<<std::endl; // 0
```

`std::move()` 可以将一个`unique_ptr`转移给另一个`unique_ptr`或者`shared_ptr`。转移后，原来的`unique_ptr`将不再拥有对内存的控制权，将变为空指针。

```cpp
std::unique_ptr<int> p1 = std::make_unique<int>(0);
std::unique_ptr<int> p2 = std::move(p1); 
// now, p1 is nullptr
```

## 2.2 shared_ptr

`std::shared_ptr<T>`是一个类模板，它的对象行为像指针，但是它还能记录有多少个对象共享它管理的内存对象。多个`std::shared_ptr<T>`可以共享同一个对象。当最后一个`std::shared_ptr<T>`被销毁时，它会自动释放它所指向的对象。一个`shared_ptr<T>`指针可以通过`make_shared<T>`函数来创建，也可以通过拷贝或赋值另一个`shared_ptr`来创建。

### 底层原理

```cpp

element_type*	   _M_ptr;         // Contained pointer.
__shared_count<_Lp>  _M_refcount;    // Reference counter.
```

`std::shared_ptr`在内部维护一个引用计数，其只有两个指针成员，一个指针是所管理的数据的地址；还有一个指针是控制块的地址，包括引用计数、weak\_ptr计数、删除器(Deleter)、分配器(Allocator)。因为不同shared\_ptr指针需要共享相同的内存对象，因此**引用计数的存储是在堆上的**。而unique\_ptr只有一个指针成员，指向所管理的数据的地址。因此一个shared\_ptr对象的大小是raw\_pointer大小的两倍。

![](/images/posts/cplusplus/smartPtr.png)
