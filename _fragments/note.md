test
1.cpp编译过程

预处理（#include,#if,#ifndef）->编译(.cpp->.s)->汇编(.s->.0)->link(many .s file link to the elf)

2. elf 文件的构成
   .text:代码段，已经编译的代码
   .rodata:只读数据段，不可修改，放常量的
   .data:数据段，已经初始化的全局变量
   .bss:.bss段，放未初始化全局变量

3.cpp内存分区
栈
堆
全局区：bss+data，全局变量+静态变量
常量区：rodata，常量
代码段：text，不可修改，二进制文件

4.作用域与生命周期
全局变量和静态变量的生命周期是一样的，跟着程序走
静态局部变量的作用域是局部的
静态全局变量的作用域是文件作用域，在整个文件内可见，但在文件外部不可访问

5.内存对齐
int 放4倍地址，double要8倍地址
在32位编译环境下默认4字节对齐，在64位编译环境下默认8字节对齐。

6.大小端
高位放在较大的地址处，则称小端序（Little-Endian）；反之则称大端序（Big-Endian）。

7.智能指针
unique_ptr: 独享指针，不能拷贝构造和赋值，但可以使用move转移所有权；离开作用域就自动释放

share_ptr: 共享指针，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，同时将计数减一，当计数减为 0 时会自动释放内存空间，从而避免了内存泄漏。
非线程安全，shared_ptr 的计数是原子操作实现的，利用 atmoic CAS 指令实现。可以看到 share_ptr 的内存模型，当引用计数和 weak count 同时为 0 时，share_ptr 对象才会被最终释放掉
weak_ptr: 弱指针，指向 share_ptr 指向的对象，是 shared_ptr 对象管理的资源的观察者，能够解决由 shared_ptr 带来的循环引用问题。具体做法就是将一个类中的成员变量由shareptr改为weakptr，因为weakptr不会增加usecount,所以能正常析构

8.cpp11新特性
auto和decltype
labmda表达式
右值：非持久化的对象，不能取引用
move()
auto_ptr->unique_ptr
constexpr，常量表达式

9.sizeOf 和 strlen区别
strlen 是头文件中的函数，sizeof 是 C++ 中的运算符。
strlen(expression);
sizeof(expression);
sizeOf不会运行expression，strlen会运行expression

10.new的过程
new的作用，分配对象，然后返回它的指针
创建对象的过程：分配空间-》调用构造函数-》返回指针
new在自由存储区分配内存
malloc在堆上分配内存
new可被重载，分为全局重载和局部重载

11.union 和 struct
union：所有成员共享一个内存空间
struct：一个成员一个内存空间

12.volatile作用
1）阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）
2）阻止编译器调整操作 volatile 变量的指令排序。
3）写入变量时，阻止编译器对指令顺序的优化

13.返回函数中静态变量的地址会发生什么
这个静态变量会依然存在，因为局部静态变量在程序初始化的时候就创建，在程序退出时清除，
需要注意的是，初始化时，先创建全局静态变量，然后创建局部静态变量，程序死亡时，先释放局部静态变量，然后释放全局静态变量

14.多线程
为什么条件变量要和互斥锁搭配使用？
条件变量负责临界状态，如果没有，线程会被不断加锁解锁，或者sleep一段时间，如果sleep，那sleep多少时间，也是个问题
互斥锁负责 加入等待队列 和 解锁 的原子性，可能会发生死锁，比如在线程a在1->2的过程中，线程b修改了条件，并发出了信号c，那么线程a就会加入信号c的等待队列中，如果没有通知，就会一直在里面

15.memmove 和 memcpy
如果目标区域和源区域有重叠的话，memmove 能够保证源串在被覆
盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域
没有重叠则和 memcpy 函数功能相同

16.strcpy
strcpy 把含有 '\0' 结束符的字符串复制到另一个地址空间，
返回值的类型为 char*，返回值为拷贝后的字符串的首地址。
strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，可能会覆盖其他变量

17.重载，重写和隐藏
重载：根据参数列表确定调用哪个同名函数，重载不关心函数返回类型。

重写：派生类中存在重新定义的函数，发生在运行时。函数名、参数列表、返回值类型
都必须同基类中被重写的函数一致，只有函数体不同。
父类的被重写函数一定是虚函数，否则，使用父类指针指向子类对象时候，只会调用父类的函数（这时候是函数隐藏）

隐藏：在派生类中定义一个与基类成员同名的成员，这会使基类中的成员在派生类的范围内被隐藏。
可以使用Base::display();访问到基类函数

18.多态
多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到
派生类的对象，使得基类指针呈现不同的表现方式。

多态通过虚函数实现，虚函数地址保存在虚表中，虚表地址在实例对象中的内存空间中

基类指针指向派生类对象时，基类的虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数然后调用执行

19.对象限制创建在栈和堆上
限制在堆上：构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部
使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类
中能够访问析构函数。通过调用 create() 函数在堆上创建对象。

限制对象只能建立在栈上：将 operator new() 设置为私有。
原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函
数，因此只要对该函数加以限制，就能够防止对象建立在堆上

20.虚函数和纯虚函数详解
虚函数：被  virtual  关键字修饰的成员函数，C++  的虚函数在运行时动态绑定，从而实现多态

纯虚函数：纯虚函数在类中声明时，用 virtual 关键字修饰且加上 =0，且没有函数的具体实现；含
有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口定义，没有具
体的实现方法；继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实
例化对象。

21.虚函数相关
虚函数表存放的内容：类的虚函数的地址。

虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。

虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取
到虚函数的偏移量。

虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个
对象在创建时都有自己的虚表指针 vptr，来指向类的虚函数表 vtable
就是说虚表指针不共用（用来指向虚表），虚函数表公用

如果子类没有重写虚函数A，那么父类和子类的虚函数A的地址是一样的
如果子类重写虚函数A，虚函数A就有两个地址，父类和子类的虚函数A的地址是不一样的

22.构造析构能设置成虚函数么
构造函数不能设置虚函数：因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，
但是没有虚函数的指针，虚函数的指针只有在创建了对象才有

析构函数必须设置虚函数：如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类
的成员所占的空间释放掉

23.避免拷贝构造
1.声明private（类的成员函数和友元函数依然可以调用）
2.父类的拷贝构造private，子类来继承这个父类
3.delete关键字

24.空类
声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。

25.拷贝构造函数
说明 1：ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？
前者是赋值构造，后者没有实例化，所以是拷贝构造

说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 = ex1; 会出现什么问题？
构造 ex3，实质上是 ex3.A(ex1)，如果不是引用类型，会递归调用拷贝构造函数.

说明 3：为什么 ex2.fun(ex1); 会调用拷贝构造函数？
当一个函数以值传递参数时（例如 ex2.fun(ex1);），编译器会创建一个对象的副本，这个过程会调用类的拷贝构造函数来创建这个副本。

什么时候会调用拷贝构造函数？

1. 直接初始化和拷贝初始化
2. 值传递形参或者返回类型时
3. 花括号初始化一个数组的时候

26.构造函数的执行顺序
按照子类声明父类的顺序，依次执行父类构造（优先虚继承【解决菱形继承问题】构造）
按照子类的变量顺序，依次执行其构造函数
执行子类的构造

27.类的成员初始化
全局变量和静态变量在main函数之前就创建成功了，静态变量需要在class外初始化
类中 const 成员常量必须在构造函数初始化列表中初始化

28.禁止实例化的方法
1.写一个纯虚函数
2.讲所有构造函数都设置为private
3.讲所有构造函数都delete

29.动态绑定的实现
用虚表指针指向虚表中函数地址时候，会先查函数在虚表中的索引，
比如索引是0，那么就是 *(p->vptr)[0],找到函数入口
执行这条语句  *(p->vptr)[0]() ，完成函数的调用

30.深浅拷贝的区别
深拷贝：与原对象占用一块空间，栈堆都拷贝
浅拷贝，占用不同空间，只拷贝栈

如果对象中有指针变量，最好用深拷贝，因为当两个对象指向同一块内存空间，如果使
用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存

31.左值和右值
左值：表达式结束后还存在的值，可以通过&取地址，右值能赋值给左值
右值：表达式结束后不存在的值，不能同&取地址；
函数返回值，可以是左值也可以是右值

左值引用就是普通的引用
右值引用就是 转移语义 和 精确传递，&& 作为右值引用的声明符。
右值引用必须绑定到右值的引用，通过 && 获得。右值引用只能绑定到一个将要销毁的对象
上，因此可以自由地移动其资源

引用折叠原理：只要有左值引用就是左值引用，全部是右值引用才是右值引用

32.move函数
作用就是将左值转化为右值引用
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
return static_cast<typename remove_reference<T>::type &&>(t);
}
首先通过template来实现move既可以放左值引用和右值引用，
接着使用remove_reference去除引用类型，返回变量type
最后运用static_cast强制转换，返回type&& 右值引用

forward：perfect forward 用于模板编程，解决传递参数时的临时对象（右值）被强制转换为左值的问题
如果外面传来了右值临时变量, 它就转发右值并且启用move语义.
如果外面传来了左值, 它就转发左值并且启用copy. 然后它也还能保留const.

为什么要使用 const & 作为函数参数?
const左值引用是可以指向右值的，const左值引用不会修改指向值，因此可以指向右值

33.野指针和悬空指针
野指针：未初始化的指针、
悬空指针：指向的内容被释放，但指针还是指向它

34.指针和引用
指针：一个变量，保存这另一个变量的内存地址
引用：是一个别名，另一个变量的别名。实际上是具有自动间接寻址的常量指针，编译器自动为引
用使用 * 运算符。

二者区别
是否可变：指针可变，引用不可变
是否占内存：指针占内存，引用不占
是否可为空：指针可以为空，引用不能为空，必须绑定一个对象
是否能多级：指针可以多级，也就是存在指针的指针；引用不能多级，不能指定引用的引用

35.常量指针和指针常量
常量指针：指向一个常量的指针，指向的内容不能改
指针常量：指针是个常量，指针本身不能改

36.函数指针
函数指针就是指向函数的指针

fun1和&fun1的区别
函数名 fun1 存放的是函数的首地址，它是个函数类型 void
&fun1 表示指向函数对象 fun1 的地址，是一个指针类型。它的类型是 int (*)(int,int)，因此 fun1 和 &fun1 的值是一样的
&fun1 是一个表达式，函数此时作为一个对象，取对象的地址，该表达式的值是一个指针

37.4个cast强转
static_cast:基本数据类型的转换；向下转型不安全，需要dynamic_cast
const_cast:强制去掉const/volatile属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性
reinterpret_cast:指针/引用类型到长整型之间的转换
dynamic_cast:用于带虚函数的基类或派生类的指针/引用对象的转换；转换失败返回 NULL；不能用于基本数据类型的转换
主要用于安全的向下转型，即父转子;向上转型时候，和static_cast 一样
只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功

38.结构体判断相等的方法
需要重载操作符 == 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构
体是否相等，因为 memcmp 函数是逐个字节进行比较的，结构体中存在内存对齐，产生垃圾值，故而不能

39.值传递 引用传递 指针传递的区别
值传递：形参是实参的拷贝，对形参的操作不会影响实参
指针传递：拷贝的是指针的值，拷贝后形参和实参的指针不同，但是指向地址一样
引用传递：形参是引用类型，堆形参的操作会影响实参

按照函数形参定义的逆序，依次将参数压入栈内，如果是值传递，则压入栈中的是一个临时变量，该变量与传入的值内容相同；
如果是指针传递或者引用传递，则压入栈的可能是一个临时的指针变量，该指针指向与传入的指针指向的内容相同。

40.模板和重载区别
函数模板本质上是对不同的输入产生了不同的函数，需要的代码量少
重载本质上就是特征标重载，代码量多

41.迭代器
输入迭代器(Input Iterator)：只能向前单步迭代元素，不允许修改由该迭代器所引用的元素；
输出迭代器(Output Iterator)：只能向前单步迭代元素，对由该迭代器所引用的元素只有写权限；
向前迭代器(Forward Iterator)：该迭代器可以在一个区间中进行读写操作，它拥有输入迭代
器的所有特性和输出迭代器的部分特性，以及向前单步迭代元素的能力；
双向迭代器(Bidirectional Iterator)：在向前迭代器的基础上增加了向后单步迭代元素的能力；
随机访问迭代器(Random Access Iterator)：不仅综合以后 4 种迭代器的所有功能，还可以像指针那样进行算术计算

容器 vector、deque 提供随机访问迭代器，list 提供双向迭代器，set 和 map 提供向前迭代器

5个typename
value_type:迭代器指向对象的类型
difference_type:两个迭代器之间的距离
reference_type:迭代器指向对象的类型的引用，如果value_type是T，那么对应的reference_type就是T&
pointer_type:相应的指针类型
iterator_categorty:之前提到的5种迭代器

42.类型萃取
当我们需要得到迭代器包含的原生指针 指向的对象类型时，需要使用类型萃取

43.进程和线程
进程是独立执行单元，拥有自己独立的内存空间。
线程则是进程中的更小执行单元，多个线程共享相同的进程内存空间。多线程常用于进程内的并发执行，允许更高效的资源共享和通信。

进程之间通讯：管道(pipe)
有名管道 (namedpipe)
信号量(semaphore)
消息队列(messagequeue)
信号 (sinal)
共享内存(shared memory)
套接字(socket)

线程之间通讯：锁机制
wait/notify
volatile内存共享
信号量
信号

44.多线程
互斥量mutex：防止同时访问共享资源的程序对象；只有lock和unlock两种状态

共享互斥量share_mutex:保护共享数据不被多个线程同时访问。

互斥量包装器mutex_guard:使用了 RAII 的机制对互斥量进行类模板封装，构造时加锁，析构时解锁

条件变量condition variable：实现多个线程间的同步操作
当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒

虚假唤醒以及如何避免虚假唤醒：
notify_all() 时多个线程都被唤醒，但此时实际共享区却只有少数几个线程可以操作，这时就会造成其他线
程被虚假唤醒，可以在 wait 唤醒后再次进行检测 condition 解决虚假唤醒。
通常的解决办法：在条件变量阻塞的代码处增加一个 while 循环，如果被唤醒就要检查一下条
件是否符合，如果不符合则要再次进入阻塞等待。这样即避免了忙等待，又避免了虚假唤醒问题

45.emplace_back代替push_back
在平时我们习惯性的尾插用push_back()去完成，但是如果是尾插临时对象的话，
push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

emplace是移动构造，push是拷贝构造；
emplace_back(a);
push_back(a);这时候是一样的，因为都是左值

46：为什么不能在ArrayList的For-Each循环中删除元素
在For-Each循环中直接调用ArrayList的remove()方法会导致ConcurrentModificationException异常。这是因为For-Each循环实际上使用迭代器遍历集合，
在删除元素后，迭代器的状态无法同步更新，导致遍历时的结构发生变化，从而抛出异常。

47.碰撞检测

48.cpp sort函数的底层实现
个数<16, 则直接用插排
递归深度>2lgn, 则使用堆排序
否则使用快速排序

49.auto怎么实现的
C++11中的auto关键字是用来自动推导表达式或变量的实际类型的。使用auto关键字做类型自动推导时，依次施加一下规则：如果初始化表达式是引用，则去除引用语义。

auto的工作原理是:
1.编译器看到auto,会查看初始化表达式的类型,并将该类型作为auto变量的类型。
2.如果初始化表达式的类型可以确定,则使用该类型。如果初始化表达式包含了多个类型,则使用与初始化表达式兼容的共同类型。
3.如果无法确定类型,则报错。

hinstance管net，hport，相当于从壳子向内看，hcell管hpin，相当于从壳子往外看。

//状态
enum StepStatus {
NOT_START = 1,
RUNNING = 2,
PAUSE = 3,
SUCCESS = 4,
ERROR = 5
}
//状态信息
struct StepInfo {
1: string step,
2: StepStatus status,
3: optional i64 startTime, // start run time, 13-digital millseconds
4: optional i64 endTime,   // end run time, 13-digital millseconds
5: optional string error,  // error information
}
//异常
exception EdaException {
1: i32 code, // 1001 - config error, 1002 - service error, 1003 - crash
2: string msg
}

需要提供的方法：run,pause,resume,query,report,

难点在于暂停和重启：pause的话，改参数的话，就需要看改的参数是否会对之前的步骤产生影响，如果产生了影响，就需要重跑，
否则，子线程通过循环判断isPaused变量来决定是否执行具体逻辑。当isPaused为true时，子线程会调用cv.wait(lock)来暂停执行，并释放锁。当父线程将isPaused设置为false并调用cv.notify_one()时，子线程会被唤醒，并继续执行。

难点：executor碰到不知名的bug，导致挂了
答：加入心跳机制，2S一次report to manager

因为后续加了很多元件的信息，导致json非常大
答：json 10W行+（2mb），使用cpp的zlib的deflate算法压缩，再由java的inflate算法解密
TBinay没他好
机器配置：16c+96G，
